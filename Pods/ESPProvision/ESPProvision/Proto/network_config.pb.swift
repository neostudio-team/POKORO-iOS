// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: network_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum NetworkConfigMsgType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case typeCmdGetWifiStatus // = 0
  case typeRespGetWifiStatus // = 1
  case typeCmdSetWifiConfig // = 2
  case typeRespSetWifiConfig // = 3
  case typeCmdApplyWifiConfig // = 4
  case typeRespApplyWifiConfig // = 5
  case typeCmdGetThreadStatus // = 6
  case typeRespGetThreadStatus // = 7
  case typeCmdSetThreadConfig // = 8
  case typeRespSetThreadConfig // = 9
  case typeCmdApplyThreadConfig // = 10
  case typeRespApplyThreadConfig // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .typeCmdGetWifiStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeCmdGetWifiStatus
    case 1: self = .typeRespGetWifiStatus
    case 2: self = .typeCmdSetWifiConfig
    case 3: self = .typeRespSetWifiConfig
    case 4: self = .typeCmdApplyWifiConfig
    case 5: self = .typeRespApplyWifiConfig
    case 6: self = .typeCmdGetThreadStatus
    case 7: self = .typeRespGetThreadStatus
    case 8: self = .typeCmdSetThreadConfig
    case 9: self = .typeRespSetThreadConfig
    case 10: self = .typeCmdApplyThreadConfig
    case 11: self = .typeRespApplyThreadConfig
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .typeCmdGetWifiStatus: return 0
    case .typeRespGetWifiStatus: return 1
    case .typeCmdSetWifiConfig: return 2
    case .typeRespSetWifiConfig: return 3
    case .typeCmdApplyWifiConfig: return 4
    case .typeRespApplyWifiConfig: return 5
    case .typeCmdGetThreadStatus: return 6
    case .typeRespGetThreadStatus: return 7
    case .typeCmdSetThreadConfig: return 8
    case .typeRespSetThreadConfig: return 9
    case .typeCmdApplyThreadConfig: return 10
    case .typeRespApplyThreadConfig: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NetworkConfigMsgType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NetworkConfigMsgType] = [
    .typeCmdGetWifiStatus,
    .typeRespGetWifiStatus,
    .typeCmdSetWifiConfig,
    .typeRespSetWifiConfig,
    .typeCmdApplyWifiConfig,
    .typeRespApplyWifiConfig,
    .typeCmdGetThreadStatus,
    .typeRespGetThreadStatus,
    .typeCmdSetThreadConfig,
    .typeRespSetThreadConfig,
    .typeCmdApplyThreadConfig,
    .typeRespApplyThreadConfig,
  ]
}

#endif  // swift(>=4.2)

struct CmdGetWifiStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RespGetWifiStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Status = .success

  var wifiStaState: WifiStationState = .connected

  var state: RespGetWifiStatus.OneOf_State? = nil

  var wifiFailReason: WifiConnectFailedReason {
    get {
      if case .wifiFailReason(let v)? = state {return v}
      return .authError
    }
    set {state = .wifiFailReason(newValue)}
  }

  var wifiConnected: WifiConnectedState {
    get {
      if case .wifiConnected(let v)? = state {return v}
      return WifiConnectedState()
    }
    set {state = .wifiConnected(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_State: Equatable {
    case wifiFailReason(WifiConnectFailedReason)
    case wifiConnected(WifiConnectedState)

  #if !swift(>=4.1)
    static func ==(lhs: RespGetWifiStatus.OneOf_State, rhs: RespGetWifiStatus.OneOf_State) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.wifiFailReason, .wifiFailReason): return {
        guard case .wifiFailReason(let l) = lhs, case .wifiFailReason(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wifiConnected, .wifiConnected): return {
        guard case .wifiConnected(let l) = lhs, case .wifiConnected(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct CmdGetThreadStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RespGetThreadStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Status = .success

  var threadState: ThreadNetworkState = .attached

  var state: RespGetThreadStatus.OneOf_State? = nil

  var threadFailReason: ThreadAttachFailedReason {
    get {
      if case .threadFailReason(let v)? = state {return v}
      return .datasetInvalid
    }
    set {state = .threadFailReason(newValue)}
  }

  var threadAttached: ThreadAttachState {
    get {
      if case .threadAttached(let v)? = state {return v}
      return ThreadAttachState()
    }
    set {state = .threadAttached(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_State: Equatable {
    case threadFailReason(ThreadAttachFailedReason)
    case threadAttached(ThreadAttachState)

  #if !swift(>=4.1)
    static func ==(lhs: RespGetThreadStatus.OneOf_State, rhs: RespGetThreadStatus.OneOf_State) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.threadFailReason, .threadFailReason): return {
        guard case .threadFailReason(let l) = lhs, case .threadFailReason(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.threadAttached, .threadAttached): return {
        guard case .threadAttached(let l) = lhs, case .threadAttached(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct CmdSetWifiConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ssid: Data = Data()

  var passphrase: Data = Data()

  var bssid: Data = Data()

  var channel: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CmdSetThreadConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataset: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RespSetWifiConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Status = .success

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RespSetThreadConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Status = .success

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CmdApplyWifiConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CmdApplyThreadConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RespApplyWifiConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Status = .success

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RespApplyThreadConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Status = .success

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NetworkConfigPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: NetworkConfigMsgType = .typeCmdGetWifiStatus

  var payload: NetworkConfigPayload.OneOf_Payload? = nil

  var cmdGetWifiStatus: CmdGetWifiStatus {
    get {
      if case .cmdGetWifiStatus(let v)? = payload {return v}
      return CmdGetWifiStatus()
    }
    set {payload = .cmdGetWifiStatus(newValue)}
  }

  var respGetWifiStatus: RespGetWifiStatus {
    get {
      if case .respGetWifiStatus(let v)? = payload {return v}
      return RespGetWifiStatus()
    }
    set {payload = .respGetWifiStatus(newValue)}
  }

  var cmdSetWifiConfig: CmdSetWifiConfig {
    get {
      if case .cmdSetWifiConfig(let v)? = payload {return v}
      return CmdSetWifiConfig()
    }
    set {payload = .cmdSetWifiConfig(newValue)}
  }

  var respSetWifiConfig: RespSetWifiConfig {
    get {
      if case .respSetWifiConfig(let v)? = payload {return v}
      return RespSetWifiConfig()
    }
    set {payload = .respSetWifiConfig(newValue)}
  }

  var cmdApplyWifiConfig: CmdApplyWifiConfig {
    get {
      if case .cmdApplyWifiConfig(let v)? = payload {return v}
      return CmdApplyWifiConfig()
    }
    set {payload = .cmdApplyWifiConfig(newValue)}
  }

  var respApplyWifiConfig: RespApplyWifiConfig {
    get {
      if case .respApplyWifiConfig(let v)? = payload {return v}
      return RespApplyWifiConfig()
    }
    set {payload = .respApplyWifiConfig(newValue)}
  }

  var cmdGetThreadStatus: CmdGetThreadStatus {
    get {
      if case .cmdGetThreadStatus(let v)? = payload {return v}
      return CmdGetThreadStatus()
    }
    set {payload = .cmdGetThreadStatus(newValue)}
  }

  var respGetThreadStatus: RespGetThreadStatus {
    get {
      if case .respGetThreadStatus(let v)? = payload {return v}
      return RespGetThreadStatus()
    }
    set {payload = .respGetThreadStatus(newValue)}
  }

  var cmdSetThreadConfig: CmdSetThreadConfig {
    get {
      if case .cmdSetThreadConfig(let v)? = payload {return v}
      return CmdSetThreadConfig()
    }
    set {payload = .cmdSetThreadConfig(newValue)}
  }

  var respSetThreadConfig: RespSetThreadConfig {
    get {
      if case .respSetThreadConfig(let v)? = payload {return v}
      return RespSetThreadConfig()
    }
    set {payload = .respSetThreadConfig(newValue)}
  }

  var cmdApplyThreadConfig: CmdApplyThreadConfig {
    get {
      if case .cmdApplyThreadConfig(let v)? = payload {return v}
      return CmdApplyThreadConfig()
    }
    set {payload = .cmdApplyThreadConfig(newValue)}
  }

  var respApplyThreadConfig: RespApplyThreadConfig {
    get {
      if case .respApplyThreadConfig(let v)? = payload {return v}
      return RespApplyThreadConfig()
    }
    set {payload = .respApplyThreadConfig(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    case cmdGetWifiStatus(CmdGetWifiStatus)
    case respGetWifiStatus(RespGetWifiStatus)
    case cmdSetWifiConfig(CmdSetWifiConfig)
    case respSetWifiConfig(RespSetWifiConfig)
    case cmdApplyWifiConfig(CmdApplyWifiConfig)
    case respApplyWifiConfig(RespApplyWifiConfig)
    case cmdGetThreadStatus(CmdGetThreadStatus)
    case respGetThreadStatus(RespGetThreadStatus)
    case cmdSetThreadConfig(CmdSetThreadConfig)
    case respSetThreadConfig(RespSetThreadConfig)
    case cmdApplyThreadConfig(CmdApplyThreadConfig)
    case respApplyThreadConfig(RespApplyThreadConfig)

  #if !swift(>=4.1)
    static func ==(lhs: NetworkConfigPayload.OneOf_Payload, rhs: NetworkConfigPayload.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cmdGetWifiStatus, .cmdGetWifiStatus): return {
        guard case .cmdGetWifiStatus(let l) = lhs, case .cmdGetWifiStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respGetWifiStatus, .respGetWifiStatus): return {
        guard case .respGetWifiStatus(let l) = lhs, case .respGetWifiStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cmdSetWifiConfig, .cmdSetWifiConfig): return {
        guard case .cmdSetWifiConfig(let l) = lhs, case .cmdSetWifiConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respSetWifiConfig, .respSetWifiConfig): return {
        guard case .respSetWifiConfig(let l) = lhs, case .respSetWifiConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cmdApplyWifiConfig, .cmdApplyWifiConfig): return {
        guard case .cmdApplyWifiConfig(let l) = lhs, case .cmdApplyWifiConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respApplyWifiConfig, .respApplyWifiConfig): return {
        guard case .respApplyWifiConfig(let l) = lhs, case .respApplyWifiConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cmdGetThreadStatus, .cmdGetThreadStatus): return {
        guard case .cmdGetThreadStatus(let l) = lhs, case .cmdGetThreadStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respGetThreadStatus, .respGetThreadStatus): return {
        guard case .respGetThreadStatus(let l) = lhs, case .respGetThreadStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cmdSetThreadConfig, .cmdSetThreadConfig): return {
        guard case .cmdSetThreadConfig(let l) = lhs, case .cmdSetThreadConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respSetThreadConfig, .respSetThreadConfig): return {
        guard case .respSetThreadConfig(let l) = lhs, case .respSetThreadConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cmdApplyThreadConfig, .cmdApplyThreadConfig): return {
        guard case .cmdApplyThreadConfig(let l) = lhs, case .cmdApplyThreadConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respApplyThreadConfig, .respApplyThreadConfig): return {
        guard case .respApplyThreadConfig(let l) = lhs, case .respApplyThreadConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension NetworkConfigMsgType: @unchecked Sendable {}
extension CmdGetWifiStatus: @unchecked Sendable {}
extension RespGetWifiStatus: @unchecked Sendable {}
extension RespGetWifiStatus.OneOf_State: @unchecked Sendable {}
extension CmdGetThreadStatus: @unchecked Sendable {}
extension RespGetThreadStatus: @unchecked Sendable {}
extension RespGetThreadStatus.OneOf_State: @unchecked Sendable {}
extension CmdSetWifiConfig: @unchecked Sendable {}
extension CmdSetThreadConfig: @unchecked Sendable {}
extension RespSetWifiConfig: @unchecked Sendable {}
extension RespSetThreadConfig: @unchecked Sendable {}
extension CmdApplyWifiConfig: @unchecked Sendable {}
extension CmdApplyThreadConfig: @unchecked Sendable {}
extension RespApplyWifiConfig: @unchecked Sendable {}
extension RespApplyThreadConfig: @unchecked Sendable {}
extension NetworkConfigPayload: @unchecked Sendable {}
extension NetworkConfigPayload.OneOf_Payload: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension NetworkConfigMsgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TypeCmdGetWifiStatus"),
    1: .same(proto: "TypeRespGetWifiStatus"),
    2: .same(proto: "TypeCmdSetWifiConfig"),
    3: .same(proto: "TypeRespSetWifiConfig"),
    4: .same(proto: "TypeCmdApplyWifiConfig"),
    5: .same(proto: "TypeRespApplyWifiConfig"),
    6: .same(proto: "TypeCmdGetThreadStatus"),
    7: .same(proto: "TypeRespGetThreadStatus"),
    8: .same(proto: "TypeCmdSetThreadConfig"),
    9: .same(proto: "TypeRespSetThreadConfig"),
    10: .same(proto: "TypeCmdApplyThreadConfig"),
    11: .same(proto: "TypeRespApplyThreadConfig"),
  ]
}

extension CmdGetWifiStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CmdGetWifiStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CmdGetWifiStatus, rhs: CmdGetWifiStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RespGetWifiStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RespGetWifiStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "wifi_sta_state"),
    10: .standard(proto: "wifi_fail_reason"),
    11: .standard(proto: "wifi_connected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.wifiStaState) }()
      case 10: try {
        var v: WifiConnectFailedReason?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.state != nil {try decoder.handleConflictingOneOf()}
          self.state = .wifiFailReason(v)
        }
      }()
      case 11: try {
        var v: WifiConnectedState?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .wifiConnected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .wifiConnected(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.wifiStaState != .connected {
      try visitor.visitSingularEnumField(value: self.wifiStaState, fieldNumber: 2)
    }
    switch self.state {
    case .wifiFailReason?: try {
      guard case .wifiFailReason(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    }()
    case .wifiConnected?: try {
      guard case .wifiConnected(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RespGetWifiStatus, rhs: RespGetWifiStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.wifiStaState != rhs.wifiStaState {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CmdGetThreadStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CmdGetThreadStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CmdGetThreadStatus, rhs: CmdGetThreadStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RespGetThreadStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RespGetThreadStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "thread_state"),
    10: .standard(proto: "thread_fail_reason"),
    11: .standard(proto: "thread_attached"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.threadState) }()
      case 10: try {
        var v: ThreadAttachFailedReason?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.state != nil {try decoder.handleConflictingOneOf()}
          self.state = .threadFailReason(v)
        }
      }()
      case 11: try {
        var v: ThreadAttachState?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .threadAttached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .threadAttached(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.threadState != .attached {
      try visitor.visitSingularEnumField(value: self.threadState, fieldNumber: 2)
    }
    switch self.state {
    case .threadFailReason?: try {
      guard case .threadFailReason(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    }()
    case .threadAttached?: try {
      guard case .threadAttached(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RespGetThreadStatus, rhs: RespGetThreadStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.threadState != rhs.threadState {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CmdSetWifiConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CmdSetWifiConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "passphrase"),
    3: .same(proto: "bssid"),
    4: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ssid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.passphrase) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.bssid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssid.isEmpty {
      try visitor.visitSingularBytesField(value: self.ssid, fieldNumber: 1)
    }
    if !self.passphrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.passphrase, fieldNumber: 2)
    }
    if !self.bssid.isEmpty {
      try visitor.visitSingularBytesField(value: self.bssid, fieldNumber: 3)
    }
    if self.channel != 0 {
      try visitor.visitSingularInt32Field(value: self.channel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CmdSetWifiConfig, rhs: CmdSetWifiConfig) -> Bool {
    if lhs.ssid != rhs.ssid {return false}
    if lhs.passphrase != rhs.passphrase {return false}
    if lhs.bssid != rhs.bssid {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CmdSetThreadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CmdSetThreadConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dataset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataset.isEmpty {
      try visitor.visitSingularBytesField(value: self.dataset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CmdSetThreadConfig, rhs: CmdSetThreadConfig) -> Bool {
    if lhs.dataset != rhs.dataset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RespSetWifiConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RespSetWifiConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RespSetWifiConfig, rhs: RespSetWifiConfig) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RespSetThreadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RespSetThreadConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RespSetThreadConfig, rhs: RespSetThreadConfig) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CmdApplyWifiConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CmdApplyWifiConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CmdApplyWifiConfig, rhs: CmdApplyWifiConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CmdApplyThreadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CmdApplyThreadConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CmdApplyThreadConfig, rhs: CmdApplyThreadConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RespApplyWifiConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RespApplyWifiConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RespApplyWifiConfig, rhs: RespApplyWifiConfig) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RespApplyThreadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RespApplyThreadConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RespApplyThreadConfig, rhs: RespApplyThreadConfig) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NetworkConfigPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NetworkConfigPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    10: .standard(proto: "cmd_get_wifi_status"),
    11: .standard(proto: "resp_get_wifi_status"),
    12: .standard(proto: "cmd_set_wifi_config"),
    13: .standard(proto: "resp_set_wifi_config"),
    14: .standard(proto: "cmd_apply_wifi_config"),
    15: .standard(proto: "resp_apply_wifi_config"),
    16: .standard(proto: "cmd_get_thread_status"),
    17: .standard(proto: "resp_get_thread_status"),
    18: .standard(proto: "cmd_set_thread_config"),
    19: .standard(proto: "resp_set_thread_config"),
    20: .standard(proto: "cmd_apply_thread_config"),
    21: .standard(proto: "resp_apply_thread_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.msg) }()
      case 10: try {
        var v: CmdGetWifiStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cmdGetWifiStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cmdGetWifiStatus(v)
        }
      }()
      case 11: try {
        var v: RespGetWifiStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .respGetWifiStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .respGetWifiStatus(v)
        }
      }()
      case 12: try {
        var v: CmdSetWifiConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cmdSetWifiConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cmdSetWifiConfig(v)
        }
      }()
      case 13: try {
        var v: RespSetWifiConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .respSetWifiConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .respSetWifiConfig(v)
        }
      }()
      case 14: try {
        var v: CmdApplyWifiConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cmdApplyWifiConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cmdApplyWifiConfig(v)
        }
      }()
      case 15: try {
        var v: RespApplyWifiConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .respApplyWifiConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .respApplyWifiConfig(v)
        }
      }()
      case 16: try {
        var v: CmdGetThreadStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cmdGetThreadStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cmdGetThreadStatus(v)
        }
      }()
      case 17: try {
        var v: RespGetThreadStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .respGetThreadStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .respGetThreadStatus(v)
        }
      }()
      case 18: try {
        var v: CmdSetThreadConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cmdSetThreadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cmdSetThreadConfig(v)
        }
      }()
      case 19: try {
        var v: RespSetThreadConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .respSetThreadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .respSetThreadConfig(v)
        }
      }()
      case 20: try {
        var v: CmdApplyThreadConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cmdApplyThreadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cmdApplyThreadConfig(v)
        }
      }()
      case 21: try {
        var v: RespApplyThreadConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .respApplyThreadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .respApplyThreadConfig(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.msg != .typeCmdGetWifiStatus {
      try visitor.visitSingularEnumField(value: self.msg, fieldNumber: 1)
    }
    switch self.payload {
    case .cmdGetWifiStatus?: try {
      guard case .cmdGetWifiStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .respGetWifiStatus?: try {
      guard case .respGetWifiStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .cmdSetWifiConfig?: try {
      guard case .cmdSetWifiConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .respSetWifiConfig?: try {
      guard case .respSetWifiConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .cmdApplyWifiConfig?: try {
      guard case .cmdApplyWifiConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .respApplyWifiConfig?: try {
      guard case .respApplyWifiConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .cmdGetThreadStatus?: try {
      guard case .cmdGetThreadStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .respGetThreadStatus?: try {
      guard case .respGetThreadStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .cmdSetThreadConfig?: try {
      guard case .cmdSetThreadConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .respSetThreadConfig?: try {
      guard case .respSetThreadConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .cmdApplyThreadConfig?: try {
      guard case .cmdApplyThreadConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .respApplyThreadConfig?: try {
      guard case .respApplyThreadConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NetworkConfigPayload, rhs: NetworkConfigPayload) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
